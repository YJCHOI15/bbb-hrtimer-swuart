# TI AM335x 리눅스 hrtimer 기반 Software UART 구현

## 구현 목표

- AM335x BBB에서 커널 hrtimer와 GPIO 레지스터 직접 접근으로 9600bps 소프트웨어 UART(TX/RX)를 구현

---

## 개발 스택

| 구성 | 내용 |
| --- | --- |
| SoC/보드 | TI AM335x / BeagleBone Black |
| 커널 | Linux(일반 커널, PREEMPT_RT 미적용 환경) |
| 동작 메커니즘 | hrtimer, IRQ(FALLING edge) |
| 주변장치 | GPIO 직접 MMIO 접근 |
| 유저공간 I/F | 문자 디바이스 `/dev/sw_uart_hr` |
| 유틸 | udev, Saleae Logic 2(타이밍 검증) |

---

## 구현 배경

- **HW UART 자원 부족/핀 멀티플렉싱 제약**을 SW로 보완할 필요 있음
- 사용자 공간 비트뱅잉은 **스케줄링 지터**로 신뢰도 낮음 → **커널 hrtimer** 기반으로 타이밍 제어 정밀도 향상 시도

---

## 데이터 샘플링 과정 (RX)

각 데이터 비트(D1 ~ D8)와 스톱 비트에서 타이머가 만료돼 rx 콜백 함수가 호출된다. 

콜백 함수에서 각 비트를 처리해 데이터에 쓰거나 정상 프레임인지 검사한다. 

<img width="1112" height="314" alt="image" src="https://github.com/user-attachments/assets/554cdf76-26ff-422c-bd4c-fbfcf142c6d1" /> <BR><BR>

---

## 드라이버 설계

- **hrtimer**: ns 해상도 + `hrtimer_forward()`로 **위상 드리프트 최소화**
- **타이머 모드**: `HRTIMER_MODE_REL_PINNED`로 **CPU 코어 이동에 따른 지터 최소화**
- **GPIO 접근**: `ioremap()`으로 **SET/CLR/DATAIN/OE** 레지스터 직접 제어
- **IRQ 전략**: 스타트 비트 하강 엣지에서만 진입, 프레임 수신 중에는 `disable_irq_nosync()`로 **재진입 차단**

---

## 구현 결과 (TX)

- 9600bps에서 **문자열 송신 정상 동작** 확인함
    
<img width="1278" height="124" alt="image" src="https://github.com/user-attachments/assets/21ac09e6-0bd8-4597-9339-76060e0f2719" /> <BR><BR>

    
- 위상 고정(매 비트마다 `hrtimer_forward(prev_expire, bit_period)`)으로 누적 오차 억제함
    
<img width="911" height="135" alt="image" src="https://github.com/user-attachments/assets/2b76f065-5d0e-4e8b-92ea-ec0e774087bf" /> <BR><BR>

    
- TX 라인은 **아이들=HIGH**, 스타트 비트에서 LOW, 이후 LSB-first 전송함

---

## 구현 결과 및 한계 (RX)

- 로직 애널라이저 분석 결과, 9600 baud에서 **비트 폭은 평균 약 104 µs이다**.
- 또한 스톱 비트 종료 → 다음 프레임 시작(하강 엣지)까지 간격이 **약 49 µs**로 관측된다(프레임마다 소폭 변동 존재함)
    
<img width="1450" height="312" alt="image" src="https://github.com/user-attachments/assets/0e106e42-4bca-4ac5-9f36-a86a855f313e" /> <BR><BR>

    

- 이상적인 샘플링은 **스타트 비트 하강 엣지 + 1.5비트(≈156 µs)** 지점에서 D1를 읽고, 이후 매 비트마다 중앙 시점에서 샘플링하는 것이다.
- 그러나 **IRQ latency**로 인해 최초 샘플(D1) 정렬이 불안정하여, 중앙 샘플링을 꾸준히 유지하기 어려웠다.

| 단계 | 시간 기록 | 이전 단계와의 시간 차이 (µs) | 분석 |
| --- | --- | --- | --- |
| FALLING EDGE | 10197.858877 | - | Start Bit 감지(T=0) |
| data bit1 | 10197.859094 | 217 | **1.5비트(≈156 µs)보다 늦음** |
| data bit2 | 10197.859182 | 88 | **1비트(≈104 µs)보다  약간 빠름** |
| data bit3 | 10197.859285 | 103 | 정상 범위 |
| data bit4 | 10197.859389 | 104 | 정상 범위 |
| data bit5 | 10197.859493 | 104 | 정상 범위 |
| data bit6 | 10197.859597 | 104 | 정상 범위 |
| data bit7 | 10197.859702 | 105 | 정상 범위 |
| data bit8 | 10197.859806 | 104 | 정상 범위 |
| framing error | 10197.859913 | 107 | 누적 오프셋으로 **프레이밍 에러** 발생 |
- 위 측정에서 **초기 샘플 지연이 1.5비트 기준보다 크게 발생**했음을 확인했다. 이로 인해 뒤따르는 샘플들이 한 비트씩 밀리는 패턴이 나타났다.

- 이에 따라, **초기 지연 보상**으로 하강 엣지 이후 대기 시간을 **1.5비트 → 1.0비트**로 단축하여 실험했다.
- 보상 적용 후에 **D1 처리 시점에서 약 157 µs 경과** 사례가 관측되었지만, 실제 수신에서는 **비트 밀림**이 여전히 발생했다.
- 아래 그림과 같이 157us 시점에서 D1 비트를 읽음으로써 1이 기록되어야 한다.
    
<img width="589" height="188" alt="image" src="https://github.com/user-attachments/assets/bbd8fa25-b0ba-4eb0-a036-8363021fb229" /> <BR><BR>

    
- 로그 상 **하강 엣지 직후 RX 핸들러 진입 시점에서 이미 GPIO가 D1(=1) 상태**로 관측되는 경우가 반복되었다(스타트 비트 0 구간을 일부 놓침).
    
<img width="428" height="163" alt="image" src="https://github.com/user-attachments/assets/6ed2823c-e8f5-4333-b848-11d5acfd8bd3" /> <BR><BR>

    
- 따라서 원인은 **gpio irq latency**라고 추정했다.

- 결론적으로 **일반 리눅스 커널 + hrtimer만으로는 RX를 완전 안정화하기 어려움**을 확인했다.
- 안정화를 위해서는 다음과 같은 대안이 필요하다.
    - **PREEMPT_RT 커널** 적용해 IRQ를 스레드화하고 latency를 축소
    - 비글본 블랙의 PRU(Programmable Real-time Unit)를 사용해 데이터 비트 샘플링을 하드 RT로 수행하여 us 지터 제거
    - RTOS: 리눅스 대신 FreeRTOS와 같은 실시간 운영체제를 사용하여 커널 단순화와 결정적 스케줄링을 통해 인터럽트 및 태스크 지연 축소
