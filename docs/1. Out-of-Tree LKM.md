# Out-of-Tree LKM

## 개발 전략

- OOT(Out-of-Tree) 방식으로 디바이스 드라이버를 LKM(Loadable Kernel Module) 형태로 개발, 검증함
- 최종적으로 In-Tree 전환 여부는 미정임
- `class_create()` / `device_create()` 를 사용해 udev와 연동되며, 주번호는 동적 할당되고 `/dev/sw_uart_hr` 노드를 자동 생성함

### In-Tree vs Out-of-Tree

| **항목**    | **In-Tree 방식**                               | **OOT 방식**                               |
| --------- | -------------------------------------------- | ---------------------------------------- |
| **정의**    | 드라이버 코드가 Linux 커널 소스 트리에 포함되어 커널과 함께 빌드 및 배포 | 드라이버 코드가 커널 소스 트리 외부에서 독립적으로 개발 및 컴파일    |
| **빌드 방식** | 커널 빌드 프로세스와 통합, 전체 커널 컴파일 필요                 | 별도 Makefile로 `.ko` 모듈 파일 생성, 독립 컴파일 가능   |
| **장점**    | 높은 안정성 및 호환성<br>커뮤니티 지원<br>표준화된 배포           | 빠르고 유연한 개발<br>독점 드라이버 가능<br>커널 소스 수정 불필요 |
| **단점**    | 복잡한 개발 절차<br>커널 빌드 시간 길음<br>공개 의무            | 버전 호환성 문제<br>유지보수 부담<br>디버깅 어려움          |


호스트(x64, WSL2, Ubuntu-22.04)에서 OOT 모듈을 빌드하고, BBB(Target)에 배포하여 로드/언로드하며 드라이버 테스트 

---

## 1. 빌드 준비

- **Target**: BeagleBone Black, **커널** `5.10.168-ti-r83`, **아키텍처** ARMv7 hard-float
- **(참고)** 사용자 공간 바이너리의 GLIBC 이슈를 피하기 위해 BBB 이미지를 **Debian 12 (glibc 2.36)** 로 갱신함
    - 커널 모듈(.ko)은 커널 ABI에 종속되므로 **GLIBC와 무관**함(유저 프로그램에는 영향 있음)

<img width="572" height="181" alt="image" src="https://github.com/user-attachments/assets/382d1958-ec84-48f0-9236-d02fe361ca08" />


### 1.1 크로스 컴파일러 설치 (호스트)

BeagleBone Black(ARMv7-A, hard-float, GNU/Linux) 타겟 크로스 컴파일러 설치

```bash
sudo apt update
sudo apt install gcc-arm-linux-gnueabihf
```

### 1.2 BBB 커널 헤더/빌드 트리 준비 (타겟과 호스트 동기화)

**BBB에서 확인/설치:**

```bash
dpkg -l | grep linux-headers
sudo apt-get update
sudo apt-get install linux-headers-$(uname -r)
```

**호스트에서 BBB와 동일 커널 소스/심볼 수집:**

```bash
git clone -b v5.10.168-ti-r83 https://github.com/beagleboard/linux.git
# linux 디렉토리를 내 원격 레포지토리에서 참조(링크)만 하고 싶을때 git clone 대신 사용
# git submodule add -b v5.10.168-ti-r83 https://github.com/beagleboard/linux.git linux
cd linux/

# BBB의 설정/심볼 동기화
scp debian@192.168.7.2:/boot/config-5.10.168-ti-r83 .config
scp debian@192.168.7.2:/lib/modules/5.10.168-ti-r83/build/Module.symvers .

scripts/config --set-str CONFIG_LOCALVERSION "-ti-r83"

make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- olddefconfig
make HOSTCC=gcc HOSTCXX=g++ ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- prepare modules_prepare
```

---

## 2. 커널 모듈과 사용자 프로그램 빌드 및 복사

**모듈 `Makefile` 이 있는 폴더에서 빌드함:**

```bash
make # .ko 파일과 바이너리 유저 프로그램 생성
cd ..
./deploy.sh # BBB로 배포
```

---

## 3. 모듈 로드/udev 연동/언로드

BBB는 init 프로세스로 systemd가 사용된다. 

따라서 systemd 서비스로 구동되는 udev 데몬을 통해 디바이스 노드를 자동 생성하도록 한다. 

### 3.1 모듈 로드

```bash
sudo insmod /home/debian/sw_uart/swuart_hrtimer.ko
```

### 3.2 udev 연동 확인

**클래스 생성 확인:**

<img width="800" height="187" alt="image" src="https://github.com/user-attachments/assets/36623c4f-11db-4a95-bc7a-46eea2164434" />


**/dev/swuart_hr 디바이스 노드 자동 생성됨 (udev 동작) → 주번호가 238로 자동 할당됨**

<img width="709" height="53" alt="image" src="https://github.com/user-attachments/assets/7d5a3b64-d2be-4ebc-9fb5-5c82cd671d7a" />


**이처럼 udev 데몬이 `/sys/class/` 를 보고 있다가 아래와 같은 dev 파일을 읽어서 주번호와 부번호를 알아내고, `/dev` 아래에 해당 디바이스 노드를 생성함**

<img width="743" height="52" alt="image" src="https://github.com/user-attachments/assets/a2027ff2-43d3-4a3d-b4dc-b88fa9a8dcff" />


### 3.3 모듈 언로드

```bash
sudo rmmod swuart_hrtimer
```